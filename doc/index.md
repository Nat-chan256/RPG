## Оглавление

+ [Общее описание работы](#description)
+ [Классы, их взаимодействие и описание](#classesHead)
+ [Оформление кода](#codeStyle)
+ [Коммиты и ветки](#todo)
+ [Итоговая документация. Чем отличается от этого](#natasha)

### <a name="description"></a> Общее описание работы

Нам необходимо создать несколько модулей, которые, работая вместе,смогут показывать картинку, воспроизводить звук и отвечать за логику игры.

Модуль, отвечающий за отрисовку графики у нас уже есть - это SFML. Проблема только в том, что эта библиотека, по сути, умеет только рисовать и отлавливать события окна (по части графики, звука касаются аналогичные рассуждения), но не умеет управлять текстурами, звуком и прочими рисурсами. Поэтому первый модуль - что-то типа простенькой базы данных, который мог бы подгружать и выгружать ресурсы в / из памяти. Ровно так же SFML не знает что и где рисовать, как воспроизводить анимации.

Второй аспект - графический интерфейс. SFML представляет хорошее решение для простенькой игры в плане рисования мира, но GUI он рисовать не умеет. А хотелось бы милые кнопошки-крутилки, а то через консольку как-то не красиво. Для этого используем [ImGui](https://github.com/ocornut/imgui "Тута гит"). Вообще, это не самое лучшее решение, но оно весьма простое - в отличии от Qt (а этот парень весьма не особо-то и имеет альтернативы в плюсах) не использует CallBack функции и сигналы-слоты, а просто позволяет проверить нажата ли кнопка в данном кадре. Короче говоря - тут проще, а значит меньше шанс накосячить.

Ну и то, ради чего мы тут собрались - сам игровой движок. Выше графический был, да. Он частично пересекается с графическим - например, хз куда правильнее деть слой - в графический или игровой? Вроде он рисуется, а вроде сущности понимают по слоям где они находятся (логично, что на тайлике дорожки ничего не происходит, а на тайлике с лавой боль и отчаяние). Можно разделить в целом, но это уже не так красиво - в одном классе хранить матрицу, а в другом рисовать ее. Ля, это идея.<br>
Но вернемся к движку. Также тут будут триггеры, враги, взаимодйствие между объектами. Сами объекты. Много чего.

Кроме того, было бы мило связать игру с консолькой. Например, ввести возможность вводить команды и скрипты на языке Lua. Ты, вроде, не хотела идти в веб и все такое, а там умение обращаться с языком Lua будет полезны. Вообще интересная вещица - он может быть полезен всегда и везде. Кроме того, он крайне прост. Я уверен, тебе он понравится и будет полезен в будущем.<br>
Зы А еще на нем можно писать роботов в майнкрафте и геррисмоде - это самое главное!

И из мелочей - все данные мы будем хранить в формате JSON. Можно было использовать XML и, например, редактор TileMapEditor (полезная хрень - работает с любым ЯП), но это уже не так интересно.

#### Ход работы

Во время разбаотки мы идем снизу вверх - от базовых и простейших классов к более сложным. Например, мы сначала создаем тайлик, потом слой, потом карту, потом уровень и так далее (*хотя сделали наоборот, но ладно. Это кака, так низя :с*).

На всю каку, которая будет тем или иным образом написана надо сделать документацию. Но зачем писать ее самостоятельно, если компуктер может ее генерировать? Относительно самостоятельно, убирая от нас часть работы. Например, можно использовать штуку типа mkdocs. Мне лично нравится mkdocs, но можно использовать то, что захошь ты. Можешь глянуть [Doxygen](http://www.doxygen.nl/), [Pandoc](https://pandoc.org/) и [mkdocs](https://www.mkdocs.org/).

### <a name="classesHead"></a> Классы, их взаимодействие и описание

И так, краткое описание классов, которые будут в игре (если их не будет, то не пустят в стим. Не пустят в стим - не заработает миллион!).

Всеми ресурсами управляет ResourceMenager (надо его подебажить на всякий пожарный, а то вдруг из-за него память утекает). Он владеет всеми ресурсы и может раздавать их другим классам - тайликам, сущностям и так далее. От того, как он работет, зависит достаточно много. Важно то, что он будет владельцем ресурса, а все остальные лишь его пользователями - поэтому он имеет в себе std::shared_ptr, а остальные std::weak_ptr. Этот момент я еще не переделал в коде.

Основным классом приложения (вот этот момент достаточно часто используется в любом приложении. Этакий стандартный паттерн) будет класс RPG. Данный класс определяет то, как все взаимодействует, отлавливает события, знает состояние игры на данный момент, отвечает за обновления игры каждый кадр. То есть, он хранит в себе информацию о текущем состоянии игры (и стек состояний), все менеджеры ресурсов и так далее.<br>
Второй по опасности после ResourceMenager - косяки в нем могут быть весьма критическими.

Теперь о том, что уже имеем: с карты и уровня. Самое базовое для карты - тайлики и слои. Тайлик содержит в себе информацию о своей текстуре, и о том, как с ним взаимодействуют сущности (ну там кактус урон наносит, дорожка ускоряет). Карта содержит в себе массив слоев, информацию о том, на каком слое располагаются сущности (читай - с чем они будут пытаться пересекаться). Было бы неплохо сделать освещение через слои и маски. Должна быть возможность изменять любой тайлик на любом слое. Уровни содержат в себе карту, список сущностей на данном уровне, триггеры и все такое. О переходах по уровням поговорим позже. Там уже стек состояний подрубится.

<!-- todo -->
*Запихаю сюда описание сущностей. Когда-нибудь*

### <a name="codeStyle"></a> Оформление кода

#### Классы

+ Всегда упоминаем Virtual при наследовании от абстрактоного класса.
+ Здоровую каку (массивы, строки, журнал пропусков 29 группы) возвращаем по константной ссылке. Если что - скопируется во вне. Аналогично для передачи.
+ В объявлениях пишем название переменных. Переменные-аргументы (вообще всех функций) имеют "\_" в конце, переменные в protected и private начинаются с m\_.
+ Идентификаторы переменных-статиков просто с большой буквы. Статические методы же с маленькой. Inline никак не помечаем.

```C++
class Natasha : virtual public Human
{
public:
	const std::string& getSomeStuff() const;

	void setAge(uint8_t age_);
	uint8_t getAge() const;

	// ...

private:
	uint8_t m_age;

	// ...
};
```

#### Общее

+ Избегай здоровых строк, которые тяжело прочитать, в этом случае пытайся или разбить на несколько маленьких, или вынести переменные или еще что-то.
+ Максимально используй стандартную библиотеку. Даже для мелочей - так читаемее. Сравни две строки в примере ниже - в одной явно видно, что именно присваивается переменной maximalItem, а во второй надо немного задуматься над условной операцией.
```C++
auto maximalItem = (a > b) ? a : b;
auto maximalItem = std::max(a, b);
```
+ Не храни итераторы во вне, кроме передачи в функции. Типа не делай поле в классе вида "std::iterator ...".

### <a name="todo"></a> Коммиты и ветки

### <a name="natasha"></a> Итоговая документация. Чем отличается от этого